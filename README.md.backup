# üçÉ Quickleaf Cache

[![Crates.io](https://img.shields.io/crates/v/quickleaf.svg)](https://crates.io/crates/quickleaf)
[![License](https://img.shields.io/crates/l/quickleaf.svg)](https://github.com/lowcarboncode/quickleaf/blob/main/LICENSE)
[![Documentation](https://docs.rs/quickleaf/badge.svg)](https://docs.rs/quickleaf)

Quickleaf Cache is a **fast**, **lightweight**, and **feature-rich** in-memory cache library for Rust. It combines the simplicity of a HashMap with advanced caching features like **TTL (Time To Live)**, **filtering**, **ordering**, and **event notifications**.

## ‚ú® Features

- üöÄ **High Performance**: O(1) access with ordered key iteration
- ‚è∞ **TTL Support**: Automatic expiration with lazy cleanup
- üîç **Advanced Filtering**: StartWith, EndWith, and complex pattern matching
- üìã **Flexible Ordering**: Ascending/descending with pagination support
- üîî **Event Notifications**: Real-time cache operation events
- üéØ **LRU Eviction**: Automatic removal of least recently used items
- üõ°Ô∏è **Type Safety**: Full Rust type safety with generic value support
- üì¶ **Zero Dependencies**: Lightweight with minimal external dependencies

## üì¶ Installation

Add the following to your `Cargo.toml`:

```toml
[dependencies]
quickleaf = "0.3"
```

## üöÄ Quick Start

```rust
use quickleaf::{Quickleaf, Duration};

fn main() {
    // Create a cache with capacity of 1000 items
    let mut cache = Quickleaf::new(1000);
    
    // Insert some data
    cache.insert("user:123", "Alice");
    cache.insert("user:456", "Bob");
    
    // Retrieve data
    println!("{:?}", cache.get("user:123")); // Some("Alice")
    
    // Insert with TTL (expires in 60 seconds)
    cache.insert_with_ttl("session:abc", "temp_data", Duration::from_secs(60));
}
```

## Usage

Here's a basic example of how to use Quickleaf Cache:

```rust
use quickleaf::{Quickleaf, ListProps, Order, Filter};
use quickleaf::valu3::value::Value;

fn main() {
    let mut cache = Quickleaf::new(2);
    cache.insert("key1", 1);
    cache.insert("key2", 2);
    cache.insert("key3", 3);

    assert_eq!(cache.get("key1"), None);
    assert_eq!(cache.get("key2"), Some(&2.to_value()));
    assert_eq!(cache.get("key3"), Some(&3.to_value()));

    let list_props = ListProps::default()
        .order(Order::Asc)
        .limit(10);

    let result = cache.list(list_props).unwrap();
    for (key, value) in result {
        println!("{}: {}", key, value);
    }
}
```

### Using Filters

You can use filters to narrow down the results when listing cache entries. Here are some examples:

#### Filter by Start With

```rust
use quickleaf::{Quickleaf, ListProps, Order, Filter};

fn main() {
    let mut cache = Quickleaf::new(10);
    cache.insert("apple", 1);
    cache.insert("banana", 2);
    cache.insert("apricot", 3);

    let list_props = ListProps::default()
        .order(Order::Asc)
        .filter(Filter::StartWith("ap"))
        .limit(10);

    let result = cache.list(list_props).unwrap();
    for (key, value) in result {
        println!("{}: {}", key, value);
    }
}
```

#### Filter by End With

```rust
use quickleaf::{Quickleaf, ListProps, Order, Filter};

fn main() {
    let mut cache = Quickleaf::new(10);
    cache.insert("apple", 1);
    cache.insert("banana", 2);
    cache.insert("pineapple", 3);

    let list_props = ListProps::default()
        .order(Order::Asc)
        .filter(Filter::EndWith("apple"))
        .limit(10);

    let result = cache.list(list_props).unwrap();
    for (key, value) in result {
        println!("{}: {}", key, value);
    }
}
```

#### Filter by Start And End With

```rust
use quickleaf::{Quickleaf, ListProps, Order, Filter};

fn main() {
    let mut cache = Quickleaf::new(10);
    cache.insert("applemorepie", 1);
    cache.insert("banana", 2);
    cache.insert("pineapplepie", 3);

    let list_props = ListProps::default()
        .order(Order::Asc)
        .filter(Filter::StartAndEndWith("apple", "pie"))
        .limit(10);

    let result = cache.list(list_props).unwrap();
    for (key, value) in result {
        println!("{}: {}", key, value);
    }
}
```

### Using Events

You can use events to get notified when cache entries are inserted, removed, or cleared. Here is an example:

```rust
use quickleaf::{Quickleaf, Event};
use std::sync::mpsc::channel;
use quickleaf::valu3::value::Value;

fn main() {
    let (tx, rx) = channel();
    let mut cache = Quickleaf::with_sender(10, tx);

    cache.insert("key1", 1);
    cache.insert("key2", 2);
    cache.insert("key3", 3);

    let mut items = Vec::new();

    for data in rx {
        items.push(data);

        if items.len() == 3 {
            break;
        }
    }

    assert_eq!(items.len(), 3);
    assert_eq!(
        items[0],
        Event::insert("key1".to_string(), 1.to_value())
    );
    assert_eq!(
        items[1],
        Event::insert("key2".to_string(), 2.to_value())
    );
    assert_eq!(
        items[2],
        Event::insert("key3".to_string(), 3.to_value())
    );
}
```

### Event Types

There are three types of events:

1. `Insert`: Triggered when a new entry is inserted into the cache.
2. `Remove`: Triggered when an entry is removed from the cache.
3. `Clear`: Triggered when the cache is cleared.

## Modules

### `error`

Defines custom error types used in the library.

### `filter`

Defines the `Filter` enum used for filtering cache entries.

### `list_props`

Defines the `ListProps` struct used for specifying properties when listing cache entries.

### `quickleaf`

Defines the `Quickleaf` struct which implements the cache functionality.

## Running Tests

To run the tests, use the following command:

```sh
cargo test
```

## License

This project is licensed under the Apache 2.0 License. See the [LICENSE](LICENSE) file for more information.
